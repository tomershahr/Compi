%{
    #include "Nodes.hpp"
	#include <iostream>
	#include "hw3_output.hpp"
	#include "tables.cpp"
	using namespace output;
	using namespace std;


	extern int yylineno;
	extern int yylex();
	extern char* yytext;
	void yyerror(const char*);
	SymbolTables symbols_tables;
	string ret_type; //curr function ret type

%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SWITCH
%nonassoc CASE
%nonassoc DEFAULT
%nonassoc COLON
%nonassoc SC
%nonassoc COMMA
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%right ASSIGN
%left OR
%left AND
%left EQUALITY_RELOP
%nonassoc RELATION_RELOP
%left PLUS_MINUS
%left MULT_DIV
%right NOT
%left LBRACE RBRACE
%left LPAREN RPAREN
%right IF
%right ELSE


%%
Program : Funcs {   if(symbols_tables.getSymbolType("main").compare("VOID")!=0 || !symbols_tables.getFuncArgs("main").empty() ){errorMainMissing(); exit(0);}
                    symbols_tables.closeScope();
                };
Funcs : {}
	  | FuncDecl Funcs {};


//FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {tables.pop_back(); offsets.pop_back();};

FuncDecl : FuncDecl1 FuncDec2 {};

FuncDecl1 : RetType ID LPAREN Formals RPAREN LBRACE {
                                                      string func_name = ((Id*)$2)->name;
                                                      ret_type  =((Type*)$1)->type;
                                                      if(symbols_tables.findSymbol(func_name)){
                                                            errorDef(yylineno, func_name); exit(0);
                                                      }

                                                      if($4== nullptr){

                                                          symbols_tables.insertFuncEntry(func_name, ((Type*)$1)->type, vector<string>());
                                                       }
                                                      else{
                                                          vector<string> args_t = ((Arguments*)$4)->types;
                                                           vector<string> args_n = ((Arguments*)$4)->names;
                                                           symbols_tables.insertFuncEntry(func_name, ((Type*)$1)->type, args_t);


                                                          for(unsigned int i=0; i<args_t.size();i++){

                                                            string var_name = args_n[i];
                                                            if(symbols_tables.findSymbol(var_name)){
                                                                      errorDef(yylineno, var_name); exit(0);}
                                                            symbols_tables.insertFuncArgEntry(args_n[i], args_t[i]);
                                                          }
                                                      }
                                                    };

FuncDec2 :  Statements RBRACE { symbols_tables.closeScope();
                                //tables.pop_back(); offsets.pop_back();
                                };

RetType : Type {$$ = $1;}
		| VOID {$$ = $1;};

Formals : {$$=nullptr;}
		| FormalsList {$$= $1;};

FormalsList : FormalDecl { $$ = $1;}
			| FormalDecl COMMA FormalsList {$$ = ((Arguments*)$1)->merge($3);};

FormalDecl : Type ID {$$ = new Arguments($1, $2);};

Statements : Statement {}
		   | Statements Statement {};

Statement : LBRACE Statements RBRACE {}

		  | Type ID SC {
		  string type = ((Type*)$1)->type;
		  string name = ((Id*)$2)->name;
		  if(symbols_tables.findSymbol(name)){
		    errorDef(yylineno, name); exit(0);
			}
		  symbols_tables.insertEntry(name, type);
		  }
/*
		  | Type ID ASSIGN Exp SC {}
		  | ID ASSIGN Exp SC {}
		  | Call SC {}
	*/
		  | RETURN SC { if(ret_type.compare("VOID")!=0){errorMismatch(yylineno); exit(0);} }
/*
		  | RETURN Exp SC { string type = ((Type*)$2)->type;
		  if(ret_type.compare(type)!=0){errorMismatch(yylineno); exit(0);}}


		  | IF LPAREN Exp RPAREN Statement {}
		  | IF LPAREN Exp RPAREN Statement ELSE Statement {}
		  | WHILE LPAREN Exp RPAREN Statement {}
		  | BREAK SC {}
		  | CONTINUE SC {}
		  | SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE {};

Call : ID LPAREN ExpList RPAREN {printProductionRule(27);}
	 | ID LPAREN RPAREN {printProductionRule(28);};

ExpList : Exp {printProductionRule(29);}
		| Exp COMMA ExpList {printProductionRule(30);};


*/
Type : INT {$$ = $1;}
	 | BYTE {$$ = $1;}
	 | BOOL {$$ = $1;};
/*
Exp : LPAREN Exp RPAREN {printProductionRule(34);}
    | Exp MULT_DIV Exp {printProductionRule(35);}
	| Exp PLUS_MINUS Exp {printProductionRule(35);}
	| ID {printProductionRule(36);}
	| Call {printProductionRule(37);}
	| NUM {printProductionRule(38);}
	| NUM B {printProductionRule(39);}
	| STRING {printProductionRule(40);}
	| TRUE {printProductionRule(41);}
	| FALSE {printProductionRule(42);}
	| NOT Exp {printProductionRule(43);}
	| Exp AND Exp {printProductionRule(44);}
	| Exp OR Exp {printProductionRule(45);}
	| Exp EQUALITY_RELOP Exp {printProductionRule(46);}
	| Exp RELATION_RELOP Exp {printProductionRule(46);}


CaseList : CaseDecl CaseList {printProductionRule(48);}
		 | CaseDecl {printProductionRule(49);}
		 | DEFAULT COLON Statements {printProductionRule(50);};

CaseDecl : CASE NUM COLON Statements {printProductionRule(51);};
*/
%%
void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main() {
	return yyparse();
}
