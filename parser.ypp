%{
    #include "Nodes.hpp"
	#include <iostream>
	#include "hw3_output.hpp"
	#include "tables.cpp"
	using namespace output;
	using namespace std;


	extern int yylineno;
	extern int yylex();
	extern char* yytext;
	void yyerror(const char*);
	SymbolTables symbols_tables;
	string ret_type; //curr function ret type

%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SWITCH
%nonassoc CASE
%nonassoc DEFAULT
%nonassoc COLON
%nonassoc SC
%nonassoc COMMA
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%right ASSIGN
%left OR
%left AND
%left EQUALITY_RELOP
%nonassoc RELATION_RELOP
%left PLUS_MINUS
%left MULT_DIV
%right NOT
%left LBRACE RBRACE
%left LPAREN RPAREN
%right IF
%right ELSE


%%
Program : Funcs {   if(symbols_tables.getSymbolType("main").compare("VOID")!=0 || !symbols_tables.getFuncArgs("main").empty() ){errorMainMissing(); exit(0);}
                    symbols_tables.closeScope();
                };
Funcs : {}
	  | FuncDecl Funcs {};


//FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {tables.pop_back(); offsets.pop_back();};

FuncDecl : FuncDecl1 FuncDec2 {};

FuncDecl1 : RetType ID LPAREN Formals RPAREN LBRACE {
                                                      string func_name = ((Id*)$2)->name;
                                                      ret_type  =((Type*)$1)->type;
                                                      if(symbols_tables.findSymbol(func_name)){
                                                            errorDef(yylineno, func_name); exit(0);
                                                      }

                                                      if($4 == nullptr){

                                                          symbols_tables.insertFuncEntry(func_name, ((Type*)$1)->type, vector<string>());
                                                       }
                                                      else{
                                                          vector<string> args_t = ((Arguments*)$4)->types;
                                                           vector<string> args_n = ((Arguments*)$4)->names;
                                                           symbols_tables.insertFuncEntry(func_name, ((Type*)$1)->type, args_t);


                                                          for(unsigned int i=0; i<args_t.size();i++){

                                                            string var_name = args_n[i];
                                                            if(symbols_tables.findSymbol(var_name)){
                                                                      errorDef(yylineno, var_name); exit(0);}
                                                            symbols_tables.insertFuncArgEntry(args_n[i], args_t[i]);
                                                          }
                                                      }
                                                    };

FuncDec2 :  Statements RBRACE { symbols_tables.closeScope();
                                //tables.pop_back(); offsets.pop_back();
                                };

RetType : Type {$$ = $1;}
		| VOID {$$ = $1;};

Formals : {$$=nullptr;}
		| FormalsList {$$= $1;};

FormalsList : FormalDecl { $$ = $1;}
			| FormalDecl COMMA FormalsList {$$ = ((Arguments*)$1)->merge($3);};

FormalDecl : Type ID {$$ = new Arguments($1, $2);};

Statements : Statement {}
		   | Statements Statement {};

Statement : LBRACE Statements RBRACE {}

		  | Type ID SC {
		  string type = ((Type*)$1)->type;
		  string name = ((Id*)$2)->name;
		  if(symbols_tables.findSymbol(name)){
		    errorDef(yylineno, name); exit(0);
			}
		  symbols_tables.insertEntry(name, type);
		  }
/*
		  | Type ID ASSIGN Exp SC {}
		  | ID ASSIGN Exp SC {}
		  | Call SC {}
	*/
		  | RETURN SC { if(ret_type.compare("VOID")!=0){errorMismatch(yylineno); exit(0);} }
/*
		  | RETURN Exp SC { string type = ((Type*)$2)->type;
		  if(ret_type.compare(type)!=0){errorMismatch(yylineno); exit(0);}}


		  | IF LPAREN Exp RPAREN Statement {}
		  | IF LPAREN Exp RPAREN Statement ELSE Statement {}
		  | WHILE LPAREN Exp RPAREN Statement {}
		  | BREAK SC {}
		  | CONTINUE SC {}
		  | SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE {};

Call : ID LPAREN ExpList RPAREN {printProductionRule(27);}
	 | ID LPAREN RPAREN {printProductionRule(28);};

ExpList : Exp {$$ = new ExpList($1;)}
		| Exp COMMA ExpList {$$ = ((ExpList*)$1)->merge($3);};

Type : INT {$$ = $1;}
	 | BYTE {$$ = $1;}
	 | BOOL {$$ = $1;};

Exp : LPAREN Exp RPAREN {$$ = $2}

    | Exp MULT_DIV Exp {
	    if(!isNumber($1) || !isNumber($3))
    	        {errorMismatch(yylineno);exit(0);}
    	if(compareTypes($1,"INT")|| compareTypes($2,"INT"))
    	    {$$ = new Type("INT");}
    	else{$$ = new Type("BYTE");}
    	delete $1;
    	delete $3;
    }

	| Exp PLUS_MINUS Exp {
	        if(!isNumber($1) || !isNumber($3))
        	        {errorMismatch(yylineno);exit(0);}
        	if(compareTypes($1,"INT")|| compareTypes($2,"INT"))
        	    {$$ = new Type("INT");}
        	else{$$ = new Type("BYTE");}
        	delete $1;
        	delete $3;
	}


	| ID {
	    string name = (Id*)$1->name;
	    Entry entry;
	    if(!symbols_tables.findSymbol(name, &entry) || (entry.is_func))
            {errorUndef(yylineno, name); exit(0);}
	     $$ = new Type(entry.type);
        }


	| Call {$$=$1}

	| NUM {
	    $$ = new Type("INT");
	}
	| NUM B {
	    if((Num*)$1->value > 255)
	        {errorByteTooLarge(yylineno);exit(0);}
	    $$ = new Type("BYTE");
	}

	| STRING {$$ = new Type("STRING");}

	| TRUE {$$ = new Type("BOOL");}

	| FALSE {$$ = new Type("BOOL");}

	| NOT Exp {
	    if(!compareTypes($2,"BOOL")
	    {errorMismatch(yylineno);exit(0);}
	    $$ = $2;
	}

	| Exp AND Exp {
	    if(!compareTypes($1,"BOOL") || !compareTypes($3,"BOOL"))
	    {errorMismatch(yylineno);exit(0);}
	    $$ = $1;
	}

	| Exp OR Exp {
        if(!compareTypes($1,"BOOL") || !compareTypes($3,"BOOL"))
        {errorMismatch(yylineno);exit(0);}
        $$ = $1;
    }

	| Exp EQUALITY_RELOP Exp {
	    if(!isNumber($1) || !isNumber($3))
	        {errorMismatch(yylineno);exit(0);}
	    $$ = new Type("BOOL");
	}

	| Exp RELATION_RELOP Exp {
	    if(!isNumber($1) || !isNumber($3))
    	        {errorMismatch(yylineno);exit(0);}
    	$$ = new Type("BOOL");
    }



CaseList : CaseDecl CaseList {printProductionRule(48);}
		 | CaseDecl {printProductionRule(49);}
		 | DEFAULT COLON Statements {printProductionRule(50);};

CaseDecl : CASE NUM COLON Statements {printProductionRule(51);};
*/
%%
void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main() {
	return yyparse();
}
