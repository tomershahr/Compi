%{
    #include "Nodes.hpp"
	#include <iostream>
	#include "hw3_output.hpp"
	#include "Nodes.hpp"
	using namespace hw3_output;
	using namespace std;

	extern int yylineno;
	extern int yylex();
	extern char* yytext;
	void yyerror(const char*);
	vector<int> offsets ;  #offsets stack
	vector<Table> tables;   #symbols tables stack

%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SWITCH
%nonassoc CASE
%nonassoc DEFAULT
%nonassoc COLON
%nonassoc SC
%nonassoc COMMA
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%right ASSIGN
%left OR
%left AND
%left EQUALITY_RELOP
%nonassoc RELATION_RELOP
%left PLUS_MINUS
%left MULT_DIV
%right NOT
%left LBRACE RBRACE
%left LPAREN RPAREN
%right IF
%right ELSE


%%
Program : Funcs {};
Funcs : {}
	  | FuncDecl Funcs {};


# FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {tables.pop_back(); offsets.pop_back();};

FuncDecl : FuncDecl1 FuncDec2 {};

FuncDecl1 : RetType ID LPAREN Formals RPAREN LBRACE {
                                                      string func_name = ((Id*)$2)->name;
                                                      if(!findSymbolInScope(tables.top(),func_name){
                                                            errorDef(yylineno, func_name); exit();
                                                      }
                                                      vector<string> args_t = (Arguments*)$4.types;
                                                      vector<string> args_n = (Arguments*)$4.names;
                                                      insertFuncEntry(tables.back(), func_name, ((Type*)$1)->type, args_t)){
                                                      if(offsets.empty()){offsets.push_back(0)}
                                                      else{offsets.push_back(offsets.back())}
                                                      offsets.push_back(offsets.back());
                                                      tables.push_back(Table());
                                                      int current_offset = offsets.back()-1;
                                                      for(unsigned int i; i<args_t.size();i++){
                                                        string var_name = args_n[i];
                                                        if(!findSymbolInScope(tables.top(),var_name){
                                                                  errorDef(yylineno, var_name); exit();}
                                                        insertEntry(tables.back(), args_n[i], args_t[i], current--)
                                                      }
                                                    };

FuncDec2 :  Statements RBRACE {tables.pop_back(); offsets.pop_back();};

RetType : Type {$$ = $1;}
		| VOID {$$ = $1;};

Formals : {$$=nullptr;}
		| FormalsList {$$= $1;};

FormalsList : FormalDecl { $$ = $1;}
			| FormalDecl COMMA FormalsList {$$ = ((Arguments*)$1)->merge($3);};

FormalDecl : Type ID {$$ = new Arguments($1, $2);};
/*
Statements : Statement {}
		   | Statements Statement {};

Statement : LBRACE Statements RBRACE {}

		  | Type ID SC {
		  int current_offset = offsets.back();
		  string type = (Type*)$1->type;
		  string name = (Id*)$2->name;
		  if(!findSymbolInScope(tables.back(),name){
		  errorDef(yylineno, (Id*)$2->name); exit();}}
		  insertEntry(tables.back(),name,type,current_offset);
		  offsets.top()++;
		  delete $1;
		  delete $2;
		  }


		  | Type ID ASSIGN Exp SC {



		  }
		  | ID ASSIGN Exp SC {}
		  | Call SC {}
		  | RETURN SC {}
		  | RETURN Exp SC {}
		  | IF LPAREN Exp RPAREN Statement {}
		  | IF LPAREN Exp RPAREN Statement ELSE Statement {}
		  | WHILE LPAREN Exp RPAREN Statement {}
		  | BREAK SC {}
		  | CONTINUE SC {}
		  | SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE {};

Call : ID LPAREN ExpList RPAREN {printProductionRule(27);}
	 | ID LPAREN RPAREN {printProductionRule(28);};

ExpList : Exp {printProductionRule(29);}
		| Exp COMMA ExpList {printProductionRule(30);};

*/

Type : INT {$$ = $1;}
	 | BYTE {$$ = $1;}
	 | BOOL {$$ = $1;};
/*
Exp : LPAREN Exp RPAREN {printProductionRule(34);}
    | Exp MULT_DIV Exp {printProductionRule(35);}
	| Exp PLUS_MINUS Exp {printProductionRule(35);}
	| ID {printProductionRule(36);}
	| Call {printProductionRule(37);}
	| NUM {printProductionRule(38);}
	| NUM B {printProductionRule(39);}
	| STRING {printProductionRule(40);}
	| TRUE {printProductionRule(41);}
	| FALSE {printProductionRule(42);}
	| NOT Exp {printProductionRule(43);}
	| Exp AND Exp {printProductionRule(44);}
	| Exp OR Exp {printProductionRule(45);}
	| Exp EQUALITY_RELOP Exp {printProductionRule(46);}
	| Exp RELATION_RELOP Exp {printProductionRule(46);}


CaseList : CaseDecl CaseList {printProductionRule(48);}
		 | CaseDecl {printProductionRule(49);}
		 | DEFAULT COLON Statements {printProductionRule(50);};

CaseDecl : CASE NUM COLON Statements {printProductionRule(51);};
*/
%%
void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main() {
	return yyparse();
}
